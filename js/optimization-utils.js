// Optimization Utilities - Additional algorithmic optimizations and helpers
class OptimizationUtils {
    constructor() {\n        // Fast math constants\n        this.FAST_MATH = {\n            PI: Math.PI,\n            TWO_PI: Math.PI * 2,\n            HALF_PI: Math.PI * 0.5,\n            DEG_TO_RAD: Math.PI / 180,\n            RAD_TO_DEG: 180 / Math.PI\n        };\n        \n        // Lookup tables for frequently used functions\n        this.sinTable = [];\n        this.cosTable = [];\n        this.sqrtTable = [];\n        \n        // Initialize lookup tables\n        this.initializeLookupTables();\n        \n        // Frustum culling helper\n        this.frustum = new THREE.Frustum();\n        this.cameraMatrix = new THREE.Matrix4();\n        \n        // Distance calculation cache\n        this.distanceCache = new Map();\n        this.cacheMaxAge = 100; // milliseconds\n        \n        console.log('OptimizationUtils: Initialized with lookup tables and caching');\n    }\n    \n    // Initialize lookup tables for fast math\n    initializeLookupTables() {\n        const tableSize = 3600; // 0.1 degree precision (360 * 10)\n        \n        for (let i = 0; i < tableSize; i++) {\n            const angle = (i / 10) * this.FAST_MATH.DEG_TO_RAD;\n            this.sinTable[i] = Math.sin(angle);\n            this.cosTable[i] = Math.cos(angle);\n        }\n        \n        // Square root lookup for common values\n        for (let i = 0; i <= 10000; i++) {\n            this.sqrtTable[i] = Math.sqrt(i);\n        }\n        \n        console.log('OptimizationUtils: Lookup tables initialized');\n    }\n    \n    // Fast sine using lookup table\n    fastSin(angleDegrees) {\n        const index = Math.floor((angleDegrees % 360) * 10);\n        return this.sinTable[index] || Math.sin(angleDegrees * this.FAST_MATH.DEG_TO_RAD);\n    }\n    \n    // Fast cosine using lookup table\n    fastCos(angleDegrees) {\n        const index = Math.floor((angleDegrees % 360) * 10);\n        return this.cosTable[index] || Math.cos(angleDegrees * this.FAST_MATH.DEG_TO_RAD);\n    }\n    \n    // Fast square root using lookup table\n    fastSqrt(value) {\n        if (value <= 10000 && value >= 0) {\n            return this.sqrtTable[Math.floor(value)];\n        }\n        return Math.sqrt(value);\n    }\n    \n    // Fast distance calculation with caching\n    fastDistance(pos1, pos2, useCache = true) {\n        if (!useCache) {\n            return pos1.distanceTo(pos2);\n        }\n        \n        const key = `${pos1.x.toFixed(1)},${pos1.y.toFixed(1)},${pos1.z.toFixed(1)}-${pos2.x.toFixed(1)},${pos2.y.toFixed(1)},${pos2.z.toFixed(1)}`;\n        const now = performance.now();\n        \n        const cached = this.distanceCache.get(key);\n        if (cached && (now - cached.time) < this.cacheMaxAge) {\n            return cached.distance;\n        }\n        \n        const distance = pos1.distanceTo(pos2);\n        this.distanceCache.set(key, { distance, time: now });\n        \n        // Clean cache if it gets too large\n        if (this.distanceCache.size > 1000) {\n            this.cleanDistanceCache();\n        }\n        \n        return distance;\n    }\n    \n    // Clean old distance cache entries\n    cleanDistanceCache() {\n        const now = performance.now();\n        for (const [key, value] of this.distanceCache.entries()) {\n            if (now - value.time > this.cacheMaxAge * 10) {\n                this.distanceCache.delete(key);\n            }\n        }\n    }\n    \n    // Frustum culling check\n    isInFrustum(object, camera) {\n        if (!camera || !object) return true;\n        \n        this.cameraMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        this.frustum.setFromProjectionMatrix(this.cameraMatrix);\n        \n        // Get object bounding sphere\n        const sphere = new THREE.Sphere();\n        if (object.geometry && object.geometry.boundingSphere) {\n            sphere.copy(object.geometry.boundingSphere);\n            sphere.applyMatrix4(object.matrixWorld);\n        } else {\n            sphere.set(object.position, 1); // Default radius\n        }\n        \n        return this.frustum.intersectsSphere(sphere);\n    }\n    \n    // Level of Detail (LOD) calculation\n    calculateLOD(distance, lodLevels = [100, 500, 1000, 2000]) {\n        for (let i = 0; i < lodLevels.length; i++) {\n            if (distance < lodLevels[i]) {\n                return i; // 0 = highest detail\n            }\n        }\n        return lodLevels.length; // Lowest detail\n    }\n    \n    // Batch processing helper\n    processBatch(items, batchSize, processor, onComplete) {\n        let currentIndex = 0;\n        \n        const processBatch = () => {\n            const endIndex = Math.min(currentIndex + batchSize, items.length);\n            \n            for (let i = currentIndex; i < endIndex; i++) {\n                processor(items[i], i);\n            }\n            \n            currentIndex = endIndex;\n            \n            if (currentIndex < items.length) {\n                // Schedule next batch\n                requestAnimationFrame(processBatch);\n            } else if (onComplete) {\n                onComplete();\n            }\n        };\n        \n        processBatch();\n    }\n    \n    // Optimized vector operations\n    vectorOps = {\n        // Fast vector normalization\n        fastNormalize: (vector) => {\n            const length = this.fastSqrt(vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);\n            if (length > 0) {\n                vector.x /= length;\n                vector.y /= length;\n                vector.z /= length;\n            }\n            return vector;\n        },\n        \n        // Fast dot product\n        fastDot: (v1, v2) => {\n            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n        },\n        \n        // Fast cross product\n        fastCross: (v1, v2, result = new THREE.Vector3()) => {\n            result.x = v1.y * v2.z - v1.z * v2.y;\n            result.y = v1.z * v2.x - v1.x * v2.z;\n            result.z = v1.x * v2.y - v1.y * v2.x;\n            return result;\n        }\n    };\n    \n    // Temporal optimization - smooth interpolation\n    smoothStep(edge0, edge1, x) {\n        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));\n        return t * t * (3 - 2 * t);\n    }\n    \n    // Optimized orbital calculations\n    calculateOrbitPosition(time, semiMajorAxis, eccentricity, meanAnomaly, fastMode = false) {\n        // Solve Kepler's equation with optimized iterations\n        let E = meanAnomaly;\n        const maxIterations = fastMode ? 3 : 8;\n        \n        for (let i = 0; i < maxIterations; i++) {\n            const deltaE = (meanAnomaly - E + eccentricity * Math.sin(E)) / (1 - eccentricity * Math.cos(E));\n            E += deltaE;\n            if (Math.abs(deltaE) < 1e-6) break;\n        }\n        \n        // True anomaly\n        const v = 2 * Math.atan2(\n            Math.sqrt(1 + eccentricity) * Math.sin(E / 2),\n            Math.sqrt(1 - eccentricity) * Math.cos(E / 2)\n        );\n        \n        // Distance\n        const r = semiMajorAxis * (1 - eccentricity * Math.cos(E));\n        \n        return {\n            angle: v,\n            distance: r,\n            x: r * Math.cos(v),\n            y: r * Math.sin(v)\n        };\n    }\n    \n    // Performance profiler\n    profiler = {\n        timings: new Map(),\n        \n        start: (name) => {\n            this.timings.set(name, performance.now());\n        },\n        \n        end: (name) => {\n            const startTime = this.timings.get(name);\n            if (startTime) {\n                const elapsed = performance.now() - startTime;\n                this.timings.delete(name);\n                return elapsed;\n            }\n            return 0;\n        },\n        \n        profile: (name, fn) => {\n            this.start(name);\n            const result = fn();\n            const elapsed = this.end(name);\n            if (elapsed > 1) { // Only log if > 1ms\n                console.log(`Profile ${name}: ${elapsed.toFixed(2)}ms`);\n            }\n            return result;\n        }\n    };\n    \n    // Adaptive quality system\n    adaptiveQuality = {\n        qualityLevel: 1.0,\n        \n        adjust: (targetFPS, currentFPS) => {\n            const fpsRatio = currentFPS / targetFPS;\n            \n            if (fpsRatio < 0.8) {\n                // Reduce quality\n                this.qualityLevel = Math.max(0.1, this.qualityLevel * 0.9);\n            } else if (fpsRatio > 1.2) {\n                // Increase quality\n                this.qualityLevel = Math.min(1.0, this.qualityLevel * 1.05);\n            }\n            \n            return this.qualityLevel;\n        },\n        \n        getRecommendedLOD: () => {\n            if (this.qualityLevel > 0.8) return 0; // High\n            if (this.qualityLevel > 0.5) return 1; // Medium\n            if (this.qualityLevel > 0.2) return 2; // Low\n            return 3; // Very low\n        }\n    };\n    \n    // Throttling utilities\n    createThrottle(func, delay) {\n        let timeoutId;\n        let lastExecTime = 0;\n        \n        return function (...args) {\n            const currentTime = performance.now();\n            \n            if (currentTime - lastExecTime > delay) {\n                func.apply(this, args);\n                lastExecTime = currentTime;\n            } else {\n                clearTimeout(timeoutId);\n                timeoutId = setTimeout(() => {\n                    func.apply(this, args);\n                    lastExecTime = performance.now();\n                }, delay - (currentTime - lastExecTime));\n            }\n        };\n    }\n    \n    // Debouncing utilities\n    createDebounce(func, delay) {\n        let timeoutId;\n        \n        return function (...args) {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(() => func.apply(this, args), delay);\n        };\n    }\n    \n    // Get optimization statistics\n    getOptimizationStats() {\n        return {\n            lookupTables: {\n                sinTable: this.sinTable.length,\n                cosTable: this.cosTable.length,\n                sqrtTable: this.sqrtTable.length\n            },\n            distanceCache: {\n                size: this.distanceCache.size,\n                maxAge: this.cacheMaxAge\n            },\n            adaptiveQuality: {\n                currentLevel: this.adaptiveQuality.qualityLevel.toFixed(2),\n                recommendedLOD: this.adaptiveQuality.getRecommendedLOD()\n            }\n        };\n    }\n    \n    // Export all optimizations as global utilities\n    exportGlobalUtils() {\n        window.OptUtils = {\n            fastSin: this.fastSin.bind(this),\n            fastCos: this.fastCos.bind(this),\n            fastSqrt: this.fastSqrt.bind(this),\n            fastDistance: this.fastDistance.bind(this),\n            calculateLOD: this.calculateLOD.bind(this),\n            smoothStep: this.smoothStep.bind(this),\n            profiler: this.profiler,\n            vectorOps: this.vectorOps,\n            FAST_MATH: this.FAST_MATH\n        };\n        \n        console.log('OptimizationUtils: Global utilities exported to window.OptUtils');\n    }\n    \n    // Cleanup\n    destroy() {\n        this.distanceCache.clear();\n        this.sinTable = [];\n        this.cosTable = [];\n        this.sqrtTable = [];\n        console.log('OptimizationUtils: Cleaned up and destroyed');\n    }\n}