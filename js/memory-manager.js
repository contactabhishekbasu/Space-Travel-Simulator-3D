// Memory Manager - Optimized memory usage and garbage collection
class MemoryManager {
    constructor() {
        this.pools = new Map();
        this.activeObjects = new Set();
        this.disposables = new Set();
        
        // Memory tracking
        this.memoryStats = {
            geometries: 0,
            textures: 0,
            materials: 0,
            meshes: 0,
            totalAllocated: 0,
            totalFreed: 0
        };
        
        // GC optimization
        this.gcThreshold = 1000; // Objects before triggering cleanup
        this.lastCleanup = performance.now();
        this.cleanupInterval = 30000; // 30 seconds
        
        // Object pools for frequently created/destroyed objects
        this.initializePools();
        
        console.log('MemoryManager: Initialized with object pooling and GC optimization');
    }
    
    // Initialize object pools
    initializePools() {\n        // Vector3 pool for position calculations\n        this.createPool('Vector3', () => new THREE.Vector3(), (obj) => obj.set(0, 0, 0));\n        \n        // Sphere geometry pool for planets/moons\n        this.createPool('SphereGeometry8', () => new THREE.SphereGeometry(1, 8, 8), (geo) => {\n            // Reset geometry parameters if needed\n        });\n        \n        this.createPool('SphereGeometry16', () => new THREE.SphereGeometry(1, 16, 16), (geo) => {\n            // Reset geometry parameters if needed\n        });\n        \n        this.createPool('SphereGeometry32', () => new THREE.SphereGeometry(1, 32, 32), (geo) => {\n            // Reset geometry parameters if needed\n        });\n        \n        // Material pool for common materials\n        this.createPool('MeshPhongMaterial', () => new THREE.MeshPhongMaterial(), (mat) => {\n            mat.color.setHex(0xffffff);\n            mat.emissive.setHex(0x000000);\n            mat.emissiveIntensity = 0;\n            mat.transparent = false;\n            mat.opacity = 1;\n            mat.map = null;\n        });\n        \n        // BufferGeometry pool for dynamic objects\n        this.createPool('BufferGeometry', () => new THREE.BufferGeometry(), (geo) => {\n            geo.dispose();\n            // BufferGeometry gets recreated due to complexity of resetting\n        });\n        \n        console.log('MemoryManager: Object pools initialized');\n    }\n    \n    // Create an object pool\n    createPool(name, createFn, resetFn, initialSize = 10) {\n        const pool = {\n            objects: [],\n            createFn: createFn,\n            resetFn: resetFn,\n            created: 0,\n            reused: 0\n        };\n        \n        // Pre-populate pool\n        for (let i = 0; i < initialSize; i++) {\n            pool.objects.push(createFn());\n            pool.created++;\n        }\n        \n        this.pools.set(name, pool);\n        console.log(`MemoryManager: Created pool '${name}' with ${initialSize} objects`);\n    }\n    \n    // Get object from pool\n    getFromPool(poolName) {\n        const pool = this.pools.get(poolName);\n        if (!pool) {\n            console.warn(`MemoryManager: Pool '${poolName}' not found`);\n            return null;\n        }\n        \n        let obj;\n        if (pool.objects.length > 0) {\n            obj = pool.objects.pop();\n            pool.reused++;\n        } else {\n            obj = pool.createFn();\n            pool.created++;\n        }\n        \n        this.activeObjects.add(obj);\n        return obj;\n    }\n    \n    // Return object to pool\n    returnToPool(poolName, obj) {\n        const pool = this.pools.get(poolName);\n        if (!pool || !obj) return;\n        \n        // Reset object state\n        if (pool.resetFn) {\n            pool.resetFn(obj);\n        }\n        \n        // Return to pool if not too many\n        if (pool.objects.length < 50) { // Max pool size\n            pool.objects.push(obj);\n        } else {\n            // Dispose if pool is full\n            this.disposeObject(obj);\n        }\n        \n        this.activeObjects.delete(obj);\n    }\n    \n    // Register disposable object for tracking\n    registerDisposable(obj, type = 'unknown') {\n        this.disposables.add({ obj, type, created: performance.now() });\n        this.memoryStats[type] = (this.memoryStats[type] || 0) + 1;\n        this.memoryStats.totalAllocated++;\n    }\n    \n    // Dispose object properly\n    disposeObject(obj) {\n        if (!obj) return;\n        \n        try {\n            // Dispose Three.js objects\n            if (obj.dispose && typeof obj.dispose === 'function') {\n                obj.dispose();\n            }\n            \n            // Handle specific object types\n            if (obj.geometry && obj.geometry.dispose) {\n                obj.geometry.dispose();\n            }\n            \n            if (obj.material) {\n                if (Array.isArray(obj.material)) {\n                    obj.material.forEach(mat => {\n                        if (mat.dispose) mat.dispose();\n                        if (mat.map && mat.map.dispose) mat.map.dispose();\n                    });\n                } else {\n                    if (obj.material.dispose) obj.material.dispose();\n                    if (obj.material.map && obj.material.map.dispose) {\n                        obj.material.map.dispose();\n                    }\n                }\n            }\n            \n            // Handle textures\n            if (obj.image && obj.dispose) {\n                obj.dispose(); // Texture\n            }\n            \n            this.memoryStats.totalFreed++;\n            \n        } catch (error) {\n            console.warn('MemoryManager: Error disposing object:', error);\n        }\n    }\n    \n    // Optimized geometry creation with pooling\n    createOptimizedSphere(radius, segments = 16) {\n        let poolName;\n        if (segments <= 8) poolName = 'SphereGeometry8';\n        else if (segments <= 16) poolName = 'SphereGeometry16';\n        else poolName = 'SphereGeometry32';\n        \n        const geometry = this.getFromPool(poolName);\n        if (geometry) {\n            // Scale to desired radius\n            geometry.scale(radius, radius, radius);\n            return geometry;\n        }\n        \n        // Fallback if pool fails\n        return new THREE.SphereGeometry(radius, segments, segments);\n    }\n    \n    // Optimized material creation\n    createOptimizedMaterial(options = {}) {\n        const material = this.getFromPool('MeshPhongMaterial');\n        if (material) {\n            // Apply options\n            Object.assign(material, options);\n            if (options.color) material.color.setHex(options.color);\n            if (options.emissive) material.emissive.setHex(options.emissive);\n            return material;\n        }\n        \n        // Fallback\n        return new THREE.MeshPhongMaterial(options);\n    }\n    \n    // Batch dispose multiple objects\n    batchDispose(objects) {\n        objects.forEach(obj => this.disposeObject(obj));\n    }\n    \n    // Force garbage collection cleanup\n    forceCleanup() {\n        console.log('MemoryManager: Starting forced cleanup...');\n        \n        // Clean up disposables that are old\n        const now = performance.now();\n        const oldObjects = [];\n        \n        for (const entry of this.disposables) {\n            if (now - entry.created > 60000) { // 1 minute old\n                oldObjects.push(entry);\n            }\n        }\n        \n        oldObjects.forEach(entry => {\n            this.disposeObject(entry.obj);\n            this.disposables.delete(entry);\n        });\n        \n        // Clean up pools if they're too large\n        for (const [name, pool] of this.pools.entries()) {\n            if (pool.objects.length > 20) {\n                const excess = pool.objects.splice(20);\n                excess.forEach(obj => this.disposeObject(obj));\n                console.log(`MemoryManager: Cleaned up ${excess.length} excess objects from ${name} pool`);\n            }\n        }\n        \n        this.lastCleanup = now;\n        console.log(`MemoryManager: Cleanup complete. Disposed ${oldObjects.length} old objects`);\n    }\n    \n    // Automatic cleanup check\n    checkAutoCleanup() {\n        const now = performance.now();\n        \n        if (now - this.lastCleanup > this.cleanupInterval || \n            this.activeObjects.size > this.gcThreshold) {\n            this.forceCleanup();\n        }\n    }\n    \n    // Memory pressure optimization\n    handleMemoryPressure(level = 'medium') {\n        console.log(`MemoryManager: Handling ${level} memory pressure`);\n        \n        switch (level) {\n            case 'low':\n                // Reduce pool sizes slightly\n                for (const pool of this.pools.values()) {\n                    if (pool.objects.length > 10) {\n                        const toRemove = pool.objects.splice(10, 5);\n                        toRemove.forEach(obj => this.disposeObject(obj));\n                    }\n                }\n                break;\n                \n            case 'medium':\n                // More aggressive cleanup\n                this.forceCleanup();\n                for (const pool of this.pools.values()) {\n                    if (pool.objects.length > 5) {\n                        const toRemove = pool.objects.splice(5);\n                        toRemove.forEach(obj => this.disposeObject(obj));\n                    }\n                }\n                break;\n                \n            case 'high':\n                // Emergency cleanup\n                this.forceCleanup();\n                // Clear all pools\n                for (const pool of this.pools.values()) {\n                    pool.objects.forEach(obj => this.disposeObject(obj));\n                    pool.objects = [];\n                }\n                // Suggest garbage collection\n                if (window.gc) {\n                    window.gc();\n                }\n                break;\n        }\n    }\n    \n    // Get memory statistics\n    getMemoryStats() {\n        const poolStats = {};\n        for (const [name, pool] of this.pools.entries()) {\n            poolStats[name] = {\n                available: pool.objects.length,\n                created: pool.created,\n                reused: pool.reused,\n                efficiency: pool.created > 0 ? (pool.reused / pool.created * 100).toFixed(1) + '%' : '0%'\n            };\n        }\n        \n        return {\n            pools: poolStats,\n            activeObjects: this.activeObjects.size,\n            disposables: this.disposables.size,\n            memoryStats: this.memoryStats,\n            lastCleanup: this.lastCleanup,\n            timeSinceLastCleanup: performance.now() - this.lastCleanup\n        };\n    }\n    \n    // Memory usage estimation\n    estimateMemoryUsage() {\n        let estimated = 0;\n        \n        // Estimate based on Three.js renderer info\n        if (window.renderer && window.renderer.info) {\n            const info = window.renderer.info;\n            estimated += info.memory.geometries * 1024; // ~1KB per geometry\n            estimated += info.memory.textures * 1024 * 1024; // ~1MB per texture average\n        }\n        \n        // Add pool object estimates\n        for (const pool of this.pools.values()) {\n            estimated += pool.objects.length * 100; // ~100 bytes per pooled object\n        }\n        \n        return {\n            estimatedBytes: estimated,\n            estimatedMB: (estimated / (1024 * 1024)).toFixed(2)\n        };\n    }\n    \n    // Export memory report\n    exportMemoryReport() {\n        const report = {\n            timestamp: new Date().toISOString(),\n            stats: this.getMemoryStats(),\n            usage: this.estimateMemoryUsage(),\n            performance: window.performanceMonitor ? \n                        window.performanceMonitor.getPerformanceStats() : null\n        };\n        \n        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `space-sim-memory-${new Date().toISOString().slice(0, 10)}.json`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n        \n        console.log('MemoryManager: Memory report exported');\n    }\n    \n    // Cleanup everything\n    destroy() {\n        console.log('MemoryManager: Starting full cleanup...');\n        \n        // Dispose all active objects\n        for (const obj of this.activeObjects) {\n            this.disposeObject(obj);\n        }\n        \n        // Dispose all pooled objects\n        for (const pool of this.pools.values()) {\n            pool.objects.forEach(obj => this.disposeObject(obj));\n        }\n        \n        // Clear all collections\n        this.pools.clear();\n        this.activeObjects.clear();\n        this.disposables.clear();\n        \n        console.log('MemoryManager: Full cleanup complete');\n    }\n}